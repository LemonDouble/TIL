# Clean Architecture - 12. 컴포넌트

### 컴포넌트 원칙이란?

- 비유하자면...
- SOLID : 벽과 방에 벽돌을 배치하는 방법을 알려줌
- 컴포넌트 원칙 : 빌딩에 방을 배치하는 방법
- 대규모 소프트웨어 시스템은 작은 컴포넌트들로 이뤄진다!

### 컴포넌트란?

- 시스템 구성 요소로 배포할 수 있는 가장 작은 단위
- Java → jar, Ruby → gem, .NET → DLL

### 컴포넌트의 간략한 역사

- 옛날 옛적에는 메모리 주소가 Fixed된 값이었다.
- 또한 메모리는 많이 비쌌다.

![Untitled](https://github.com/LemonDouble/TIL/blob/main/book/Clean%20Architecture/image/Untitled5.png)

- 당시 개발자는 라이브러리를 미리 로드해 메모리에 띄워 놓고, 내가 작성한 어플리케이션을 메모리에 올렸다.
    - 이 과정에서 메모리가 모자란 경우, 어플리케이션을 반으로 쪼개 배치하기도 했다.
    - 많은 프로그램을 사용할수록, 단편화는 더 많이 일어났다!

### 재배치성

- 해결책은 재배치가 가능한 바이너리(Relocatable binary) 였다.
- 로더(Loader) 사용
    - 어플리케이션과 라이브러리를 로드할 위치를 각각 지시할 수 있게 함
    - Binary를 입력받은 후, 하나씩 차례로 로드하면서 재배치
    - 이를 통해 딱 필요한 함수만을 로드 가능하게 됨
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정
    - 프로그램이 라이브러리 함수를 Call하면 **외부 참조(external reference)**로 생성
    - 라이브러리 함수를 정의하는 프로그램은, 해당 이름을 **외부 정의(external definition)**으로 설정
    - 이를 통해 외부 정의를 로드할 위치가 정해지기만 하면, 외부 참조를 외부 정의에 **링크(Link)**가능
- 이런 방식으로 링킹 로더 (Linking Loader)가 탄생!

### 링커

- 링킹 로더 등장 이후, 프로그램을 개별적으로 컴파일/로드 하도록 분할 가능해짐.
- 하지만 프로그램의 크기가 점점 커져서, 링킹 로더가 느리다는 문제에 봉착
- 따라서 링킹 / 로드를 분할.
- 링커는 링크가 완료된 재배치 코드 만들어 줌.
- 링킹 과정은 여전히 느리지만, 로드는 빠르게 할 수 있음
- 하지만 프로그램은 더 커졌고, 결국 링킹/로드를 분할해도 전체 컴파일은 시간이 많이 걸렸음.

### 무어의 법칙

- 하지만 컴퓨터 하드웨어가 급격하게 발전, 컴포넌트 플러그인 아키텍쳐(Component plugin architecture)가 탄생함
- 마인크래프트 모드(jar) 등 생각해 보면 빠르다.