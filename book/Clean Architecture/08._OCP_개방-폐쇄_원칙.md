# Clean Architecture - 08. OCP: 개방-폐쇄 원칙

### OCP - 개방-폐쇄 원칙

- 소프트웨어 개체(artifact)의 행위는 확장할 수 있어야 하지만, 기존 개체의 코드는 변경되어선 안 된다.
- 쉽게 말하면, 요구사항을 하나 추가할 때 코드를 뜯어고치면 안 된다!

### 사고 실험

- 같은 보고서를 웹 페이지와 흑백 프린터로 출력하는 프로그램을 만든다면?
- 데이터 분석기를 통해 통일된 형식의 Data 를 만들고, 적절한 출력 모듈을 통해 내보낼 수 있다.
- 두 모듈은 분리되어 있으므로, 웹 페이지 사양이 변경되더라도 흑백 프린터 출력은 변경되지 않는다.

### 모듈 의존성

- A 컴포넌트와 B 컴포넌트가 존재한다고 생각해 보자.
- 컴포넌트 간의 의존성은, 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.

![Untitled](https://github.com/LemonDouble/TIL/blob/main/book/Clean%20Architecture/image/Untitled1.png)

- 즉, A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면, A 컴포넌트가 B 컴포넌트에 의존해야 한다!
- 위 예시의 경우, Interactor(우상단)은 다른 모든 변경으로부터 보호된다.
    - 이런 설계를 한 이유는, Interactor가 업무 규칙을 포함하기 때문이다.
    - Interactor의 비즈니스 로직이 가장 중요하고, DB, Controller 등 다른 컴포넌트는 비즈니스 로직을 실행하는 것을 돕는 부수적인 역할을 담당한다.

- 이 때, 둘 사이를 Interface를 통해 연결할 수 있다.
    - Interface를 통해, Controller가 Interactor 내부 구조에 대해서 잘 알지 못하더라도 동작할 수 있다.
    - 만약 Interface 없다면 추이 종속성(Transitive dependency)를 가지게 된다.
        - A → B, B → C 이면 A → C에 의존하는 것을 추이 종속성이라고 한다.
    - 추이 종속성이 생기면, ‘자신이 직접 사용하지 않는 요소에는 의존하지 말 것’ 이라는 원칙이 깨진다.
    - 인터페이스 분리 원칙(ISP) , 공통 재사용 원칙(CRP) 에서 다시 한번 설명할 예정..

### 결론

- OCP : 시스템을 확장하기 쉽게 하며, 변경으로 인한 영향을 최소화하는 것.
- 시스템을 컴포넌트 단위로 잘 분리하고, 의존성 계층구조를 잘 만들어 중요한 컴포넌트를 보호할 수 있다!