# 객체 지향의 사실과 오해 - Chap 01. 협력하는 객체들의 공동체

분류: OOP
자료 링크: https://digital.kyobobook.co.kr/digital/ebook/ebookDetail.ink?selectedLargeCategory=001&ejkGb=EBK&barcode=4808998139766
작성일시: 2021년 9월 5일 오후 6:44

- 서론
    - 객체지향으로 향하는 첫 걸음
        1. 클래스가 아니라 객체를 바라보자.
        2. 객체를 독립적인 존재가 아닌, 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보자.

# 1. 협력하는 객체들의 공동체

- (오해) 객체지향은 실 세계를 직접/직관적으로 모델링 할 수 있는 패러다임
    - 하지만 실제로 개발하며, 객체에 1:1 대응되는 실세계의 사물을 발견할 확률은 높지 않다.
    - 실제로는, 실세계를 모방하기 보다는 역할을 잘 수행하는 새로운 세계를 만드는 것.

---

- 커피 주문의 예시
    - 커피 주문을 한다고 가정해보자.

    - 역할
        - 손님은 커피를 주문하고, 캐셔는 커피를 주문받고, 바리스타는 커피를 만드는 역할이 있다.
    - 책임
        - 손님은 커피를 주문하고, 캐셔는 커피를 주문받고, 바리스타는 커피를 만드는 책임을 수행한다.
    - 협력
        - 손님과 캐셔와 바리스타는 협력하여, "커피 주문" 이라는 협력 관계를 완성한다.

    ---

- 요청과 응답
    - 요청 (Request)
        - 손님 - (커피 주문 요청) → 캐셔 - (커피 제조 요청) → 바리스타
        - 연쇄적인 요청이 발생
    - 응답 (Response)
        - 바리스타 - ( 커피 제조 완료 ) → 캐셔 - (커피 준비 완료) → 손님
        - 요청과 반대 방향으로 연쇄적으로 작용한다.
    - 협력은 연쇄적으로 작용한다!

    ---

- 역할과 책임
    - 바리스타는 커피를 만드는 역할(Role)이다.
    - 바리스타 역할(Role)을 가진 사람은, 커피를 만들 책임(Responsibility) 가 있다.
    - 협력을 위해 역할을 맡고, 적합한 책임을 수행함으로써 다음과 같은 개념이 생긴다.
        1. 여러 사람이 동일한 역할을 수행할 수 있다.
            - 커피만 나오면, 어떤 캐셔가 주문을 받는지 상관없다.
            - 커피만 나오면, 어떤 바리스타던지 상관 없다.
        2. 역할(Role)은 대체가능성(Substituable) 을 의미한다.
            - 캐셔 A든 B든, 커피 주문만 받을 수 있으니 대체 가능하다.
            - 요청자 (손님) 입장에서, 캐셔는 대체가능하다.
        3. 책임 수행 방식은 자율적으로 선택할 수 있다.
            - 바리스타는 "아이스 아메리카노" 이기만 하면, 얼음을 사와서 만들던 직접 얼리던 크게 문제가 되지 않는다.
            - 각 바리스타는 다양한 방식으로 역할을 수행할 수 있다.
            - 이것을 다형성 (Polymorphism) 이라고 한다!
        4. 한 사람이 동시에 여러 역할을 수행할 수도 있다.
            - 손님은 회사에 출근하면 "회사원" 이라는 Role을 수행할 수도 있다!

---

- 어플리케이션의 큰 기능은, 작은 책임으로 분할되고, 각 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다.
- 객체는 자신의 책임을 수행하는 도중, 다른 객체에게 도움을 요청하기도 한다.
- 시스템은 역할과 책임을 수행하는 객체로 분할된다.
- 기능은, 객체 간의 연쇄적인 요청/응답의 흐름으로 구성된 협력으로 구현된다.

---

- 협력 속에 사는 객체
    - OOP 어플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력
    - 하지만 실제로 협력에 참여하는 주체는 "객체"
    - 객체는 다음 두 가지 덕목에서 균형점을 찾아야 한다.
        1. 객체는 충분히 '협력적' 이어야 한다.
            - 다른 객체의 요청을 기다리고, 또 다른 객체에게 적극적으로 도움을 요청해야 한다.
            - 모든 것을 스스로 처리하는 전지전능한 객체 (God Object)는 내부적 복잡도에 의해 자멸할 뿐이다!
        2. 객체는 충분히 '자율적' 이어야 한다.
            - 다른 객체의 요청에 응답할 뿐이다!
            - 어떻게 응답할지, 언제 응답할지, 요청에 응할지 여부는 객체 스스로 결정할 수 있다!

- 객체는 상태(state)와 행동(behavior)을 함께 지닌 실체!
    - 객체가 협력에 참여하며 스스로 판단하고 스스로 결정하기 위해선, 필요한 행동과 상태를 함께 지니고 있어야 한다.
    - 객체의 자율성은 내/외부를 명확하게 구분하는 것에서 나온다. (private)
    - 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할 수 없다.
    - 객체는 다른 객체가 무엇(What)을 수행하는지는 알지만, 어떻게(How) 수행하는지는 알 수 없다.

- 객체는 요청/응답을 할 때 메세지 (Message)사용
- 객체가 메세지를 처리하는 방법 : 메서드 (Method)
- OOP 언어는, Message를 처리할 메서드를 Runtime에 결정할 수 있음!

---

## 정리

( 불완전한 정의지만, 현재의 시점에서 바라본 정리)

- 객체지향이란, 시스템을 상호작용하는 자율적 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할하는 방법
- 자율적인 객체는 상태(State), 행위(Method)를 함께 지니며, 스스로 자기 자신을 책임진다.
- 객체는 시스템 행위를 구현하기 위해 다른 객체화 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며, 역할을 관련된 행위의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메세지를 전송하고, 메세지를 수신한 객체는 메세지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.