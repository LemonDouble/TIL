# 객체 지향의 사실과 오해 - Chap 02. 이상한 나라의 객체

분류: OOP
작성일시: 2021년 9월 5일 오후 7:26

- 앨리스와 객체 이야기
    - 케이크를 먹으면 키가 커지고, 부채질을 하면 키가 작아지는 앨리스 이야기를 생각해 보자.
    - 앨리스는 작은 문에 들어가기 위해, 케이크를 먹고 부채질을 하며 몸 크기를 조절하여 자신보다 작은 문을 지나갔다.
    - 여기서, 앨리스의 키는 상태 (State)이다.
        - 앨리스의 State는 변경 가능하다.
    - 앨리스의 State는 행동(Method)를 통해 변경된다.
        - 앨리스는 케이크(), 부채() 를 통해 State를 변경할 수 있다.
        - 문을_지나감() 후 부채() 는 불가능하지만, 부채() 후 문을_지나감()은 가능하다.
        - 즉, Method의 순서는 결과에 영향을 끼친다.
    - 앨리스는 어떤 상태에 있어도 유일하게 식별 가능하다.
        - 키가 작아도,커도, 앨리스는 앨리스다.
        - State와 관계 없이 유일한 존재로 식별 가능하다.

---

## 따라서, 객체는

- 식별 가능한 개체 또는 사물
    - 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고
    - 시간처럼 추상적인 개념일 수도 있음.
    - 객체는 구별 가능한
        - 식별자
        - 특징적인 행동(Method)
        - 변경 가능한 상태(State)
    - 를 가진다.
    - 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

---

### 상태(State)

- 왜 상태가 필요한가?
    - 비행기를 탄다고 가정해 보자.
    - 지금 비행기를 타려면, 과거에 한번 이상 항공권을 발권했어야 한다.
    - 내 비행기 탑승 여부는, 과거의 "항공권 발권" 이라는 행동 여부에 의존적!

- 하지만 내가 한 모든 행동(Method)를 기억하는 것은 굉장히 불편하다.
    - 이를 단순화하기 위해 상태라는 개념이 발명
    - 내가 뭘 했는지 다 기억하지 않아도, 항공권 발권 : True/False만으로 다음 행동의 결과를 예측할 수 있다.

- 상태와 프로퍼티
    - 모든 객체의 상태는, 단순한 값과 객체의 조합으로 표현할 수 있다.
        - 앨리스의 키 = 130cm, 위치 = "통로" 등은 단순한 값이다.
        - 앨리스가 들고있는 음료는 하나의 객체이다.
        - 음료를 들고 있는지 여부를 객체를 통해 표현한 예이다.

        ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%A2%20-%20Chap%2002%20%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%82%E1%85%A1%E1%84%85%E1%85%A1%20a7066eec86eb49779443d2b656af2703/Untitled.png)

        - 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(Property)라고 한다.
        - 키, 위치, 음료는 Property이다. Property는 변경되지 않고 고정되므로, 정적이다.

        - 하지만 프로퍼티 값(Property Value)는 시간에 흐름에 따라 변경되므로 동적이다.
        - 예를 들어, 앨리스가 부채를 부치면 110cm가 될 것이다.

        - 위에서 "앨리스" 객체와 "음료" 객체는 의미 있게 연결되어 있다. ( 앨리스가 음료를 들고 있으니까)
            - 객체와 객체 사이에선 이 link가 있어야 요청을 보내고/받을 수 있다.
            - Link는 객체가 다른 객체를 참조할 수 있다는 것을 의미한다.
            - 이는 다른 객체의 식별자를 알고 있는 것으로 표현된다.

        - 앨리스-음료와 달리, 객체를 구성하는 단순한 값은 속성(Attribute)라고 한다.

        - 즉, Property는 Attribute + Link!

## 따라서, 객체의 상태는

- 특정 시점에 객체가 가지고 있는 정보의 집합으로, 객체의 구조적 특징을 표현한다.
- 객체의 상태는 객체에 존재하는 정적인 Property와, 동적인 Property 값으로 구성된다.
- 객체의 Property는 단순한 값(Attribute)와 다른 객체를 참조하는 링크(Link)로 구성된다.

- 객체의 상태는, 각 객체가 스스로 책임진다. 외부의 객체가 직접적으로 객체의 상태를 변경시킬 수 없다!
- 객체의 상태를 "직접" 변경하는 것은 불가능하지만, 객체가 제공하는 행동(Method)를 통해 간접적으로 객체의 상태를 바꿀 수 있다.

---

### 행동

- 객체의 상태는 객체의 자발적인 행동에 의해서만 변경된다.
- 행동에 의해 상태가 변경되는 것은, 행동이 부수 효과 (Side Effect)를 초래하는 것을 의미한다.
    - 케이크를 먹었다면, 케이크가 줄고 + 키가 작아지는 Side Effect 생긴다.
    - 문을 통과했다면, 위치가 "통로" 에서 "아름다운 정원" 으로 변경되는 Side Effect 생긴다!

- 상태와 행동 사이에는 다음과 같은 관계가 있다.
    - 객체의 행동은, 상태에 영향을 받는다.
    - 객체의 행동은, 상태를 변경시킨다.

### 협력과 행동

- 객체가, 다른 객체와 협력하는 유일한 방법은 Request 보내는 것이다.
    - Request 받은 객체는, 자신의 책임을 다하기 위해 적절한 방법에 따라 행동한다.
    - 즉, 객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다.

- 객체는 행동하며, 자기 자신의 상태 뿐만 아니라, 다른 객체에게 협력을 요구할 수 있다.
    - 즉, 행동의 Side Effect는 두 가지로 귀결된다.
        - 본인의 State 변경
        - 다른 협력 객체에게 Request Message 전송

## 따라서, 객체의 행동은

- 외부의 요청, 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동이다.
- 행동의 결과로, 객체는
    - 자신의 State 변경하거나
    - 다른 객체에게 Message를 전달할 수 있다.
- 객체는 행동을 통해 다른 객체와 협력하므로, 행동은 외부에 노출되어야 한다.

---

### 상태 캡슐화

- 현실에서, 앨리스가 음료를 마셨다면 앨리스(주체) 가 음료를 줄인 것이다.
    - 음료는 스스로 움직일 수 없으므로, 주체가 될 수 없다!

- 하지만, 객체지향에선 모든 객체가 자신의 State를 능동적으로 관리하는 자율적 존재다.
    - 앨리스는 음료에게 "음료를 50ml 마셨다"는 메세지만을 전달한다.
    - 음료의 남은 양을 줄일지는 "음료" 가 자율적으로 결정한다.
    - 앨리스는 음료가 정말 줄었는지 알 수 없다!

    - 송신자(Sender)는 단지 자신의 요구를 전달할 뿐이다!
    - State 변경 여부는, 수신자(Receiver)의 자율에 달려 있다!

    - 이런 구조를 통해..
        - 결과적으로 객체의 자율성을 높일 수 있다!

---

### 식별자

- 객체가 식별 가능하다는 것은, 객체를 구별할 수 있는 특정 프로퍼티가 객체 안에 존재함을 의미
- 이 프로퍼티를 "식별자" 라고 함

- 반대로, 객체가 아닌 단순한 값은 식별자가 없다.

- 객체는
    - State가 같더라도, 식별자를 통해 다른 객체임을 구별 가능하다.
- 값(Value)는
    - State가 같다면, 두 인스턴스를 같은 것으로 판단한다!
    - Value에는 식별자가 없다.

- 객체는 시간이 변경되면 State도 변경된다.
    - 따라서 가변 상태 (mutable State)를 가진다.
    - 두 객체가 한 시점에서 같더라도, 시간이 지나면 얼마든지 달라질 수 있다!
    - 따라서, 식별자를 기반으로 객체가 같은지를 판단해야 한다.
    - 이를 동일성(Identical) 이라고 한다!

- 값은 시간이 변경되어도 State가 변경되지 않는다.
    - 따라서, 불변 상태(Immutable State)를 가진다!
    - 두 값이 한 시점에서 같은 State 가지고 있다면, , 그 값들은 시간이 지나도 같은 값이다.
    - 따라서, State를 비교해 두 값이 같은지 판단할 수 있다.
    - 이를 동등성(Equality)라고 한다!

## 따라서, 식별자는

- 어떤 객체를 다른 객체와 구분하는데 사용하는 Property로, 유일한 값
- 값(Value)는 식별자를 가지지 않으므로, State를 비교(동등성: Equality) 해 두 인스턴스를 비교
- 객체는 State 변경될 수 있으므로, 식별자를 통해 두 인스턴스를 비교할 수 있다.

---

- 하지만 객체 지향 언어에서는 둘의 구변이 혼란스러울 수 있다.
    - 숫자는 Integer라는 Class로부터 만들어진다.
    - 사람은 Person이라는 Class로부터 만들어진다.
    - 하지만 숫자는 Value고, 사람은 객체다!

### 따라서,

- 전통적인 식별자가 있는 객체를 "참조 객체(Reference Object)" , 또는 엔티티(Entity)로 부른다.
- 값 객체(Value Object)는 식별자가 없는 값이다.

---

### 기계로써의 객체

- 객체의 상태를 조회하는 작업 : 쿼리 (Query)
- 객체의 상태를 변경하는 작업 : 명령 (Command)

---

### 행동이 상태를 결정한다

- 객체지향 입문자가 자주 하는 실수 : 상태를 중심으로 객체를 바라보는 것
    - 왜 이 방법이 나쁜가요?
        1. 캡슐화가 저해된다. : 상태가 객체 내부로 깔끔하게 캡슐화되지 못 하고, 공용 인터페이스에 노출될 확률이 늘어난다.
        2. 객체의 협력성이 저해된다 : 객체가 필요한 이유는, 다른 객체와 협력하기 위해서이다. 하지만 상태를 먼저 고려하면 "독립적", 또는 협력에 적합하지 않은 객체를 만들 가능성이 높아진다.
        3. 객체의 재사용성이 저해된다 : 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞추면 이를 달성하기 어렵다.

- 객체지향 설계는 애플리케이션에 필요한 협력을 생각하고, 협력에 참여하는데 필요한 행동을 생각한 후, 행동을 수행할 객체를 선택하는 방식으로 수행
    - 행동을 결절한 후에야, 행동에 필요한 정보가 무엇인지를 고려하게 되며, 이 과정에서 필요한 상태가 결정됨
    - 객체의 행동은, 즉 객체가 협력에 참여하며 완수해야 하는 책임을 의미한다!

## 따라서, "어떤 책임" 을 가지고 있는지 결정하는 과정이 전체 설계를 주도해야 한다!